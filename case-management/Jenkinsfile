// Constants
DOCKER_GROUP = 'cwds'
DOCKER_IMAGE = 'casemanagement'
DOCKER_NAME = 'cwds/casemanagement'
DOCKER_REGISTRY_CREDENTIALS_ID = '6ba8d05c-ca13-4818-8329-15d41a089ec0'
CC_TEST_REPORTER_ID = 'e90a72f974bf96ece9ade12a041c8559fef59fd7413cfb08f1db5adc04337197'
DOCKER_CONTAINER_NAME = 'cm-latest'
GITHUB_CREDENTIALS_ID = '433ac100-b3c2-4519-b4d6-207c029a103b'
GITHUB_URL = 'git@github.com:ca-cwds/case-management.git'
GIT_REFSPEC = ''
SLACK_CHANNEL = '#casemanagement-stream'
SLACK_CREDENTIALS_ID = 'slackmessagetpt2'
// Used to avoid known_hosts addition, which would require each machine to have GitHub added in advance (maybe should do?)
GIT_SSH_COMMAND = 'GIT_SSH_COMMAND="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"'

// Globals
enum VersionIncrement { MAJOR, MINOR, PATCH }

def debug(String str) {
    echo "[DEBUG] ${str}"
}

// Returns Map of Maps containing the parsed JSON from the pull request event
def getPullRequestEvent() {
  readJSON text: env.pull_request_event
}

// Takes a Map of Maps containing the parsed JSON from the pull request event
// Returns a list of label strings
def getLabels(prEvent) {
  debug("getLabels( pullRequestEvent: ${pullRequestEvent} )")
  pullRequestEvent.labels.collect([]) { it.name }
}

// Takes an array of strings (labels)
// Returns a VersionIncrement object
def getVersionIncrement(labels) {
    debug("getVersionIncrement( labels: ${labels} )")

    def versionIncrement
    def versionIncrementsFound = 0
    for(label in labels){
        switch(label) {
            case "major":
                versionIncrement = VersionIncrement.MAJOR
                versionIncrementsFound++
                break
            case "minor":
                versionIncrement = VersionIncrement.MINOR
                versionIncrementsFound++
                break
            case "patch":
                versionIncrement = VersionIncrement.PATCH
                versionIncrementsFound++
                break
        }
    }

    if(versionIncrementsFound > 1)
        throw new Exception("More than one version increment label found. Please label PR with only one of 'major', 'minor', or 'patch'")

    if(versionIncrementsFound == 0)
        throw new Exception("No labels found. Please label PR with 'major', 'minor', or 'patch'")

    return versionIncrement
}

// Compares two SemVer tags
// Returns -1 if tag1 is younger, 0 if equal, 1 if tag1 is newer
def compareTags(String tag1, String tag2) {
    debug("compareTags( tag1: ${tag1}, tag2: ${tag2} )")

    def tag1Split = tag1.tokenize('.')
    def tag2Split = tag2.tokenize('.')

    for(def index in (0..2)) {
        def result = tag1Split[index].compareTo(tag2Split[index])
        if(result != 0) {
            return result
        }
    }

    return 0
}

// Gets all the tags that match SemVer format
// Returns a list of strings (version number tags)
def getTags() {
    def gitTagOutput = sh(script: "git tag", returnStdout: true)
    debug("getTags(): git tag Output: ${gitTagOutput}")

    def tags = gitTagOutput.split("\n").findAll{ it =~ /^\d+\.\d+\.\d+$/ }
    return tags
}

// Gets a string indicating what the new tag should be in SemVer format
// Takes a list of strings in sem
// Returns a string with the new version tag
def getNewTag(List tags, VersionIncrement increment) {
    debug("getNewTag( tags: {$tags}, increment: ${increment} )")

    tags.sort{ x, y -> compareTags(x, y)}
    def mostRecentTag = tags.last()
    def mostRecentTagParts = mostRecentTag.tokenize('.')

    def newTagMajor = mostRecentTagParts[0].toInteger()
    def newTagMinor = mostRecentTagParts[1].toInteger()
    def newTagPatch = mostRecentTagParts[2].toInteger()

    switch(increment) {
        case VersionIncrement.MAJOR:
            newTagMajor++
            newTagMinor = 0
            newTagPatch = 0
            break
        case VersionIncrement.MINOR:
            newTagMinor++
            newTagPatch = 0
            break
        case VersionIncrement.PATCH:
            newTagPatch++
            break
    }

    def newTag = "${newTagMajor}.${newTagMinor}.${newTagPatch}"
    return newTag
}

//Tags the GitHub Repo
def tagRepo(String newTag) {
    debug("tagRepo( newTag: ${newTag} )")
    sshagent (credentials: [GITHUB_CREDENTIALS_ID]) {

        def tagStatus = sh(script: "git tag ${newTag}", returnStatus: true)
        if( tagStatus != 0) {
            throw new Exception("Unable to tag the repository with tag '${newTag}'")
        }

        def configStatus = sh(script: "${GIT_SSH_COMMAND} git config --global user.email cwdsdoeteam@osi.ca.gov; git config --global user.name Jenkins",
            returnStatus: true)
        if( configStatus != 0) {
            throw new Exception("Unable to push the tag '${newTag}'")
        }
        def pushStatus = sh(script: "${GIT_SSH_COMMAND} git push origin ${newTag}",
            returnStatus: true)
        if( pushStatus != 0) {
            throw new Exception("Unable to push the tag '${newTag}'")
        }
    }
}

node('cm-slave') {
  def app
    try {
      deleteDir()
        stage('Checkout') {
          checkout scm
        }

      if(env.NODE_NAME == 'cm-slave') {
        stage('Notify SaaS') {
          sh "curl -L https://codeclimate.com/downloads/test-reporter/test-reporter-latest-linux-amd64 > ./cc-test-reporter"
          sh "chmod +x ./cc-test-reporter"
          /*sh "./cc-test-reporter before-build --debug"*/
        }
        
        stage('Build Docker Image') {
          app = docker.build("${DOCKER_GROUP}/${DOCKER_IMAGE}:${env.BUILD_ID}", "-f docker/web/Dockerfile .")
        }
        app.withRun("--env CI=true") { container ->
          stage('Lint') {
            sh "docker exec -t ${container.id} yarn lint"
            sh "docker exec -t ${container.id} bundler-audit"
            sh "docker exec -t ${container.id} brakeman"
          }
          stage('Unit Test') {
            sh "docker exec -t ${container.id} yarn test"
          }
          stage('Publish Coverage Reports') {
            sh "docker cp ${container.id}:/app/coverage ./coverage"
            last_commit = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
            commited_at = sh(returnStdout: true, script: "git log -1 --pretty=format:'%ct'").trim()
            sh "chmod 755 code_climate_coverage_branch.sh"
            branch = sh(returnStdout: true, script: './code_climate_coverage_branch.sh').trim()
            sh "export GIT_COMMIT=${last_commit}"
            sh "export GIT_COMMIT_SHA=${last_commit}"
            sh "export GIT_COMMITED_AT=${commited_at}"
            sh "export GIT_BRANCH=${branch}"
            sh "./cc-test-reporter format-coverage --debug -p /app -t simplecov -o coverage/codeclimate.ruby.json coverage/ruby/.resultset.json"
            sh "./cc-test-reporter format-coverage --debug -p /app -t lcov -o coverage/codeclimate.javascript.json coverage/javascript/lcov.info"
            sh "./cc-test-reporter sum-coverage coverage/codeclimate.*.json -p 2"
            sh "./cc-test-reporter upload-coverage --debug -r ${CC_TEST_REPORTER_ID}"
          }
        }
        stage('Acceptance Test Skipped (Temp)') {
          // sh "docker-compose up -d --build"
          // sh "sleep 120"
          // sh "docker-compose exec -T --env CASE_AUTHORIZATION_ENABLED=true case-test bundle exec rspec spec/acceptance"
        }
        def newTag
        stage("Increment Tag") {
        try {
            // Link to Jenkins Job: http://jenkins.dev.cwds.io:8080/view/Dashboard/job/dashboard-autotag/
            def prEvent = getPullRequestEvent()
            debug("Increment Tag: prEvent: ${prEvent}")

            def labels = getLabels(prEvent)
            debug("Increment Tag: labels: ${labels}")

            VersionIncrement increment = getVersionIncrement(labels)
            debug("Increment Tag: increment: ${increment}")
            if(increment != null ) {
                def tags = getTags()
                debug("Increment Tag: tags: ${tags}")

                newTag = getNewTag(tags, increment)
                debug("Increment Tag: newTag: ${newTag}")

                tagRepo(newTag)

            }
        }
        catch(Exception ex) {
            error "[ERROR] ${ex}"
        }
    }
        stage('Publish Image') {
          withDockerRegistry([credentialsId: DOCKER_REGISTRY_CREDENTIALS_ID]) {
            app.push(newTag)
            app.push('latest')
          }
        }
        stage('Deploy Preint') {
          sh "curl -v 'http://${JENKINS_USER}:${JENKINS_API_TOKEN}@jenkins.mgmt.cwds.io:8080/job/preint/job/deploy-case-mng/buildWithParameters?token=${JENKINS_TRIGGER_TOKEN}&cause=Caused%20by%20Build%20${env.BUILD_ID}&APP_VERSION=${env.BUILD_ID}'"
        }
      } else {
        stage('Preint Acceptance Test') {
          sh "docker-compose up -d --build case-test"
          sh "docker-compose exec -T --env CASE_AUTHORIZATION_ENABLED=true --env CASE_WEB_BASE_URL=https://web.preint.cwds.io/casemng case-test bundle exec rspec spec/acceptance"
        }
        stage('Deploy Integration') {
          build job: '/Integration Environment/deploy-case-mng/',
            parameters: [
              string(name: 'APP_VERSION', value : "${APP_VERSION}"),
              string(name: 'inventory', value: 'inventories/integration/hosts.yml')
            ],
            wait: false
        }
      }

      stage('Clean Up') {
        sh "docker images ${DOCKER_GROUP}/${DOCKER_IMAGE} --filter \"before=${DOCKER_GROUP}/${DOCKER_IMAGE}:${env.BUILD_ID}\" -q | xargs docker rmi -f || true"
      }
    } catch(Exception e) {
      currentBuild.result = "FAILURE"
        throw e
    } finally {
      sh "docker-compose down"
        notify(currentBuild.result)
        cleanWs()
    }

}
